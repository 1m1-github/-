{
  "language": "Solidity",
  "sources": {
    "contracts/QuestionMarkGame.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\n// Useful for debugging. Remove when deploying to a live network.\n// import \"hardhat/console.sol\";\n\nuint constant WIN_THRESHOLD = 10;\nuint constant NUM_CARDS = 4 ** 4;\nuint constant BOARD_WIDTH = 7;\nuint constant COLUMN = 0;\nuint constant ROW = 1;\nuint constant BOTTOM_LEFT = 0;\nuint constant BOTTOM_RIGHT = 1;\nuint constant TOP_LEFT = 2;\nuint constant TOP_RIGHT = 3;\naddress constant ZERO_ADDRESS = address(0);\n\ncontract QuestionMarkGame {\n\n    mapping(uint => uint) public maxNumCorrectPerBoard;\n    mapping(uint => address) public winnerPerBoard;\n    mapping(uint => mapping(uint => mapping(address => bool))) guessedPerBoardPerTargetCardPerPlayer;\n    mapping(uint => mapping(address => uint)) public numCorrectPerBoardPerPlayer;\n    \n    function viewNumCorrectPerBoardPerPlayer(uint seed, address user) public view returns (uint) {\n        return numCorrectPerBoardPerPlayer[seed][user];\n    }\n\n    function check(uint targetCard, uint[2] memory guessCoordinates) private pure {\n        require(targetCard < NUM_CARDS);\n        require(0 < guessCoordinates[COLUMN]);\n        require(guessCoordinates[COLUMN] < 2*BOARD_WIDTH);\n        require(0 < guessCoordinates[ROW]);\n        require(guessCoordinates[ROW] < 2*BOARD_WIDTH);\n    }\n\n    function claimWin(uint seed) public returns (bool) {\n        if (winnerPerBoard[seed] != ZERO_ADDRESS) return false;\n        if (numCorrectPerBoardPerPlayer[seed][msg.sender] < WIN_THRESHOLD) return false;\n        winnerPerBoard[seed] = msg.sender;\n        return true;\n    }\n\n    function guess(uint seed, uint targetCard, uint[2] memory guessCoordinates) public returns (bool) {\n        check(targetCard, guessCoordinates);\n\n        if (guessedPerBoardPerTargetCardPerPlayer[seed][targetCard][msg.sender]) return false;\n        guessedPerBoardPerTargetCardPerPlayer[seed][targetCard][msg.sender] = true;\n        uint256[BOARD_WIDTH][BOARD_WIDTH] memory board = generatePermutation(seed);\n        if (isGuessCorrect(board, targetCard, guessCoordinates)) {\n            uint256[4] memory targetCardValues = numberToCard(targetCard);\n            numCorrectPerBoardPerPlayer[seed][msg.sender] += countUnique(targetCardValues);\n            if (maxNumCorrectPerBoard[seed] < numCorrectPerBoardPerPlayer[seed][msg.sender]) maxNumCorrectPerBoard[seed] = numCorrectPerBoardPerPlayer[seed][msg.sender];\n            return true;\n        }\n        return false;\n    }\n\n    function countUnique(uint[4] memory arr) public pure returns (uint) {\n        bool[4] memory seen;\n        uint uniqueCount = 0;\n\n        for (uint i = 0; i < 4; i++) {\n            if (!seen[arr[i]]) {\n                seen[arr[i]] = true;\n                uniqueCount++;\n            }\n        }\n\n        return uniqueCount;\n    }\n\n    function rotateCard(uint card) private pure returns (uint rotatedCard) {\n        // clockwise\n        uint[4] memory cardValues = numberToCard(card);\n        uint[4] memory rotatedCardValues;\n        rotatedCardValues[BOTTOM_LEFT] = cardValues[BOTTOM_RIGHT];\n        rotatedCardValues[BOTTOM_RIGHT] = cardValues[TOP_RIGHT];\n        rotatedCardValues[TOP_RIGHT] = cardValues[TOP_LEFT];\n        rotatedCardValues[TOP_LEFT] = cardValues[BOTTOM_LEFT];\n        rotatedCard = cardToNumber(rotatedCardValues);\n    }\n\n    function isGuessCorrect(uint[BOARD_WIDTH][BOARD_WIDTH] memory board, uint targetCard, uint[2] memory guessCoordinates) private pure returns (bool) {\n        check(targetCard, guessCoordinates);\n\n        uint256[4] memory targetCardValues = numberToCard(targetCard);\n\n        if (guessCoordinates[COLUMN] % 2 == 1 && guessCoordinates[ROW] % 2 == 1) {\n            // exact card\n            uint boardCard = board[guessCoordinates[ROW] / 2][guessCoordinates[COLUMN] / 2];\n            if (targetCard == boardCard) return true;\n            targetCard = rotateCard(targetCard);\n            if (targetCard == boardCard) return true;\n            targetCard = rotateCard(targetCard);\n            if (targetCard == boardCard) return true;\n            targetCard = rotateCard(targetCard);\n            if (targetCard == boardCard) return true;\n            return false;\n        } else if (guessCoordinates[COLUMN] % 2 == 0 && guessCoordinates[ROW] % 2 == 0) {\n            // 4 cards\n            uint bottomLeftCard = board[guessCoordinates[ROW] / 2 - 1][guessCoordinates[COLUMN] / 2 - 1];\n            uint256[4] memory bottomLeftCardValues = numberToCard(bottomLeftCard);\n            uint bottomRightCard = board[guessCoordinates[ROW] / 2-1][guessCoordinates[COLUMN] / 2];\n            uint256[4] memory bottomRightCardValues = numberToCard(bottomRightCard);\n            uint topLeftCard = board[guessCoordinates[ROW] / 2][guessCoordinates[COLUMN] / 2-1];\n            uint256[4] memory topLeftCardValues = numberToCard(topLeftCard);\n            uint topRightCard = board[guessCoordinates[ROW] / 2][guessCoordinates[COLUMN] / 2];\n            uint256[4] memory topRightCardValues = numberToCard(topRightCard);\n            if (bottomLeftCardValues[TOP_RIGHT] == targetCardValues[BOTTOM_LEFT] && bottomRightCardValues[TOP_LEFT] == targetCardValues[BOTTOM_RIGHT] && topLeftCardValues[BOTTOM_RIGHT] == targetCardValues[TOP_LEFT] && topRightCardValues[BOTTOM_LEFT] == targetCardValues[TOP_RIGHT]) return true;\n            targetCard = rotateCard(targetCard);\n            targetCardValues = numberToCard(targetCard);\n            if (bottomLeftCardValues[TOP_RIGHT] == targetCardValues[BOTTOM_LEFT] && bottomRightCardValues[TOP_LEFT] == targetCardValues[BOTTOM_RIGHT] && topLeftCardValues[BOTTOM_RIGHT] == targetCardValues[TOP_LEFT] && topRightCardValues[BOTTOM_LEFT] == targetCardValues[TOP_RIGHT]) return true;\n            targetCard = rotateCard(targetCard);\n            targetCardValues = numberToCard(targetCard);\n            if (bottomLeftCardValues[TOP_RIGHT] == targetCardValues[BOTTOM_LEFT] && bottomRightCardValues[TOP_LEFT] == targetCardValues[BOTTOM_RIGHT] && topLeftCardValues[BOTTOM_RIGHT] == targetCardValues[TOP_LEFT] && topRightCardValues[BOTTOM_LEFT] == targetCardValues[TOP_RIGHT]) return true;\n            targetCard = rotateCard(targetCard);\n            targetCardValues = numberToCard(targetCard);\n            if (bottomLeftCardValues[TOP_RIGHT] == targetCardValues[BOTTOM_LEFT] && bottomRightCardValues[TOP_LEFT] == targetCardValues[BOTTOM_RIGHT] && topLeftCardValues[BOTTOM_RIGHT] == targetCardValues[TOP_LEFT] && topRightCardValues[BOTTOM_LEFT] == targetCardValues[TOP_RIGHT]) return true;\n            return false;\n        } else if (guessCoordinates[COLUMN] % 2 == 1 && guessCoordinates[ROW] % 2 == 0) {\n            // 2 cards\n            uint bottomCard = board[guessCoordinates[ROW] / 2-1][guessCoordinates[COLUMN] / 2];\n            uint256[4] memory bottomCardValues = numberToCard(bottomCard);\n            uint topCard = board[guessCoordinates[ROW] / 2][guessCoordinates[COLUMN] / 2];\n            uint256[4] memory topCardValues = numberToCard(topCard);\n            if (bottomCardValues[TOP_LEFT] == targetCardValues[BOTTOM_LEFT] && bottomCardValues[TOP_RIGHT] == targetCardValues[BOTTOM_RIGHT] && topCardValues[BOTTOM_LEFT] == targetCardValues[TOP_LEFT] && topCardValues[BOTTOM_RIGHT] == targetCardValues[TOP_RIGHT]) return true;\n            targetCard = rotateCard(targetCard);\n            targetCardValues = numberToCard(targetCard);\n            if (bottomCardValues[TOP_LEFT] == targetCardValues[BOTTOM_LEFT] && bottomCardValues[TOP_RIGHT] == targetCardValues[BOTTOM_RIGHT] && topCardValues[BOTTOM_LEFT] == targetCardValues[TOP_LEFT] && topCardValues[BOTTOM_RIGHT] == targetCardValues[TOP_RIGHT]) return true;\n            targetCard = rotateCard(targetCard);\n            targetCardValues = numberToCard(targetCard);\n            if (bottomCardValues[TOP_LEFT] == targetCardValues[BOTTOM_LEFT] && bottomCardValues[TOP_RIGHT] == targetCardValues[BOTTOM_RIGHT] && topCardValues[BOTTOM_LEFT] == targetCardValues[TOP_LEFT] && topCardValues[BOTTOM_RIGHT] == targetCardValues[TOP_RIGHT]) return true;\n            targetCard = rotateCard(targetCard);\n            targetCardValues = numberToCard(targetCard);\n            if (bottomCardValues[TOP_LEFT] == targetCardValues[BOTTOM_LEFT] && bottomCardValues[TOP_RIGHT] == targetCardValues[BOTTOM_RIGHT] && topCardValues[BOTTOM_LEFT] == targetCardValues[TOP_LEFT] && topCardValues[BOTTOM_RIGHT] == targetCardValues[TOP_RIGHT]) return true;\n            return false;\n        } else {\n            // 2 cards\n            uint leftCard = board[guessCoordinates[ROW] / 2][guessCoordinates[COLUMN] / 2-1];\n            uint256[4] memory leftCardValues = numberToCard(leftCard);\n            uint rightCard = board[guessCoordinates[ROW] / 2][guessCoordinates[COLUMN] / 2];\n            uint256[4] memory rightCardValues = numberToCard(rightCard);\n            if (leftCardValues[BOTTOM_RIGHT] == targetCardValues[BOTTOM_LEFT] && rightCardValues[BOTTOM_LEFT] == targetCardValues[BOTTOM_RIGHT] && leftCardValues[TOP_RIGHT] == targetCardValues[TOP_LEFT] && rightCardValues[TOP_LEFT] == targetCardValues[TOP_RIGHT]) return true;\n            targetCard = rotateCard(targetCard);\n            targetCardValues = numberToCard(targetCard);\n            if (leftCardValues[BOTTOM_RIGHT] == targetCardValues[BOTTOM_LEFT] && rightCardValues[BOTTOM_LEFT] == targetCardValues[BOTTOM_RIGHT] && leftCardValues[TOP_RIGHT] == targetCardValues[TOP_LEFT] && rightCardValues[TOP_LEFT] == targetCardValues[TOP_RIGHT]) return true;\n            targetCard = rotateCard(targetCard);\n            targetCardValues = numberToCard(targetCard);\n            if (leftCardValues[BOTTOM_RIGHT] == targetCardValues[BOTTOM_LEFT] && rightCardValues[BOTTOM_LEFT] == targetCardValues[BOTTOM_RIGHT] && leftCardValues[TOP_RIGHT] == targetCardValues[TOP_LEFT] && rightCardValues[TOP_LEFT] == targetCardValues[TOP_RIGHT]) return true;\n            targetCard = rotateCard(targetCard);\n            targetCardValues = numberToCard(targetCard);\n            if (leftCardValues[BOTTOM_RIGHT] == targetCardValues[BOTTOM_LEFT] && rightCardValues[BOTTOM_LEFT] == targetCardValues[BOTTOM_RIGHT] && leftCardValues[TOP_RIGHT] == targetCardValues[TOP_LEFT] && rightCardValues[TOP_LEFT] == targetCardValues[TOP_RIGHT]) return true;\n            return false;\n        }\n    }\n\n    // Maps the 4 values of the card to a single number (0 to 255)\n    function cardToNumber(uint256[4] memory cardValues) private pure returns (uint256) {\n        require(cardValues.length == 4, \"Card must have exactly 4 values.\");\n        uint256 result = 0;\n        for (uint256 i = 0; i < 4; i++) {\n            require(cardValues[i] < 4, \"Each value must be between 0 and 3.\");\n            result += cardValues[i] * uint256(4**i);\n        }\n        return result;\n    }\n\n    // Maps a number (0 to 255) back to the 4 values of the card\n    function numberToCard(uint256 number) private pure returns (uint256[4] memory) {\n        require(number < 256, \"Number must be between 0 and 255.\");\n        uint256[4] memory cardValues;\n        for (uint256 i = 0; i < 4; i++) {\n            cardValues[i] = number % 4;\n            number /= 4;\n            // 40 -> 0, 10 -> 2, 2->2, 0->0\n        }\n        return cardValues;\n    }\n    \n    function generatePermutation(uint256 seed) public pure returns (uint256[BOARD_WIDTH][BOARD_WIDTH] memory board) {\n        uint256[NUM_CARDS] memory permutation;\n        for (uint256 i = 0; i < NUM_CARDS; i++) {\n            permutation[i] = i;\n        }\n        for (uint256 i = NUM_CARDS - 1; i > 0; i--) {\n            uint256 j = random(seed, i + 1);\n            (permutation[i], permutation[j]) = (permutation[j], permutation[i]);\n            seed = uint256(keccak256(abi.encodePacked(seed, i)));\n        }\n        for (uint256 i = 0; i < BOARD_WIDTH; i++) {\n            for (uint256 j = 0; j < BOARD_WIDTH; j++) {\n                board[i][j] = permutation[i*BOARD_WIDTH + j];\n            }\n        }\n    }\n\n    function random(uint256 seed, uint256 upperBound) private pure returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(seed))) % upperBound;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}